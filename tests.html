<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pomodoro Timer - Test Suite</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }

        .test-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .test-header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #667eea;
        }

        .test-header h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .test-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .test-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .test-btn-primary {
            background: #667eea;
            color: white;
        }

        .test-btn-primary:hover {
            background: #5a6fd8;
        }

        .test-btn-secondary {
            background: #f8f9fa;
            color: #666;
            border: 2px solid #e9ecef;
        }

        .test-btn-secondary:hover {
            background: #e9ecef;
        }

        .test-btn-danger {
            background: #dc3545;
            color: white;
        }

        .test-btn-danger:hover {
            background: #c82333;
        }

        .test-results {
            margin-top: 30px;
        }

        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
        }

        .test-section h3 {
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .test-item {
            margin-bottom: 15px;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #ddd;
        }

        .test-item.pass {
            background: #d4edda;
            border-left-color: #28a745;
        }

        .test-item.fail {
            background: #f8d7da;
            border-left-color: #dc3545;
        }

        .test-item.running {
            background: #fff3cd;
            border-left-color: #ffc107;
        }

        .test-name {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .test-description {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 10px;
        }

        .test-result {
            font-size: 0.9rem;
            font-weight: 500;
        }

        .test-result.pass {
            color: #28a745;
        }

        .test-result.fail {
            color: #dc3545;
        }

        .test-result.running {
            color: #856404;
        }

        .test-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border-left: 4px solid #667eea;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #666;
            font-size: 0.9rem;
        }

        .console-output {
            background: #1e1e1e;
            color: #fff;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .console-line {
            margin-bottom: 5px;
        }

        .console-line.info {
            color: #17a2b8;
        }

        .console-line.success {
            color: #28a745;
        }

        .console-line.error {
            color: #dc3545;
        }

        .console-line.warning {
            color: #ffc107;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="test-header">
            <h1>üß™ Pomodoro Timer Test Suite</h1>
            <p>Comprehensive testing for all application functionality</p>
        </div>

        <div class="test-controls">
            <button class="test-btn test-btn-primary" onclick="runAllTests()">
                üöÄ Run All Tests
            </button>
            <button class="test-btn test-btn-secondary" onclick="runDatabaseTests()">
                üóÑÔ∏è Database Tests
            </button>
            <button class="test-btn test-btn-secondary" onclick="runTimerTests()">
                ‚è±Ô∏è Timer Tests
            </button>
            <button class="test-btn test-btn-secondary" onclick="runUITests()">
                üé® UI Tests
            </button>
            <button class="test-btn test-btn-secondary" onclick="runUnitTests()">
                üî¨ Unit Tests
            </button>
            <button class="test-btn test-btn-danger" onclick="clearTestResults()">
                üóëÔ∏è Clear Results
            </button>
        </div>

        <div class="test-stats" id="test-stats">
            <div class="stat-card">
                <div class="stat-value" id="total-tests">0</div>
                <div class="stat-label">Total Tests</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="passed-tests">0</div>
                <div class="stat-label">Passed</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="failed-tests">0</div>
                <div class="stat-label">Failed</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="success-rate">0%</div>
                <div class="stat-label">Success Rate</div>
            </div>
        </div>

        <div class="test-results" id="test-results">
            <!-- Test results will be populated here -->
        </div>

        <div class="console-output" id="console-output">
            <div class="console-line info">Test console ready. Click "Run All Tests" to start.</div>
        </div>
    </div>

    <!-- Include the application files -->
    <script src="database.js"></script>
    <script src="script.js"></script>
    <script src="unit-tests.js"></script>
    
    <!-- Test suite -->
    <script>
        class PomodoroTestSuite {
            constructor() {
                this.testResults = [];
                this.totalTests = 0;
                this.passedTests = 0;
                this.failedTests = 0;
                this.pomodoroApp = null;
                this.testDatabase = null;
            }

            log(message, type = 'info') {
                const console = document.getElementById('console-output');
                const line = document.createElement('div');
                line.className = `console-line ${type}`;
                line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                console.appendChild(line);
                console.scrollTop = console.scrollHeight;
            }

            updateStats() {
                document.getElementById('total-tests').textContent = this.totalTests;
                document.getElementById('passed-tests').textContent = this.passedTests;
                document.getElementById('failed-tests').textContent = this.failedTests;
                document.getElementById('success-rate').textContent = 
                    this.totalTests > 0 ? Math.round((this.passedTests / this.totalTests) * 100) + '%' : '0%';
            }

            addTestResult(testName, description, result, details = '') {
                this.totalTests++;
                if (result) {
                    this.passedTests++;
                } else {
                    this.failedTests++;
                }

                const testResults = document.getElementById('test-results');
                const testItem = document.createElement('div');
                testItem.className = `test-item ${result ? 'pass' : 'fail'}`;
                
                testItem.innerHTML = `
                    <div class="test-name">${testName}</div>
                    <div class="test-description">${description}</div>
                    <div class="test-result ${result ? 'pass' : 'fail'}">
                        ${result ? '‚úÖ PASSED' : '‚ùå FAILED'}
                    </div>
                    ${details ? `<div class="test-details">${details}</div>` : ''}
                `;

                testResults.appendChild(testItem);
                this.updateStats();
            }

            async runAllTests() {
                this.clearResults();
                this.log('Starting comprehensive test suite...', 'info');
                
                await this.runDatabaseTests();
                await this.runTimerTests();
                await this.runUITests();
                await this.runIntegrationTests();
                
                this.log(`Test suite completed. ${this.passedTests}/${this.totalTests} tests passed.`, 
                    this.failedTests === 0 ? 'success' : 'warning');
            }

            async runDatabaseTests() {
                this.log('Running database tests...', 'info');
                
                // Test 1: Database Initialization
                try {
                    this.testDatabase = new PomodoroDatabase();
                    await this.testDatabase.init();
                    this.addTestResult(
                        'Database Initialization',
                        'Test database creation and initialization',
                        true,
                        'Database created successfully'
                    );
                } catch (error) {
                    this.addTestResult(
                        'Database Initialization',
                        'Test database creation and initialization',
                        false,
                        `Error: ${error.message}`
                    );
                }

                // Test 2: Session Storage
                try {
                    const testSession = {
                        task: 'Test Task',
                        mode: 'focus',
                        duration: 25,
                        completedAt: new Date().toISOString(),
                        sessionNumber: 1,
                        date: new Date().toISOString().split('T')[0],
                        hour: new Date().getHours(),
                        dayOfWeek: new Date().getDay(),
                        month: new Date().getMonth() + 1,
                        year: new Date().getFullYear()
                    };

                    const sessionId = await this.testDatabase.addSession(testSession);
                    this.addTestResult(
                        'Session Storage',
                        'Test adding session to database',
                        sessionId > 0,
                        `Session ID: ${sessionId}`
                    );
                } catch (error) {
                    this.addTestResult(
                        'Session Storage',
                        'Test adding session to database',
                        false,
                        `Error: ${error.message}`
                    );
                }

                // Test 3: Session Retrieval
                try {
                    const sessions = await this.testDatabase.getAllSessions();
                    this.addTestResult(
                        'Session Retrieval',
                        'Test retrieving all sessions from database',
                        sessions.length > 0,
                        `Retrieved ${sessions.length} sessions`
                    );
                } catch (error) {
                    this.addTestResult(
                        'Session Retrieval',
                        'Test retrieving all sessions from database',
                        false,
                        `Error: ${error.message}`
                    );
                }

                // Test 4: Settings Storage
                try {
                    // Verify database is initialized
                    if (!this.testDatabase.db) {
                        throw new Error('Database not initialized');
                    }

                    const testSettings = {
                        focusTime: 30,
                        breakTime: 5,
                        longBreakTime: 15,
                        sessionsBeforeLongBreak: 4,
                        soundEnabled: true
                    };

                    // Clear any existing settings first
                    await this.testDatabase.clearSettings();
                    
                    // Save test settings
                    await this.testDatabase.saveSettings(testSettings);
                    
                    // Add a small delay to ensure database operations complete
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Load settings
                    const loadedSettings = await this.testDatabase.loadSettings();
                    
                    // Debug logging
                    this.log(`Original settings: ${JSON.stringify(testSettings)}`, 'info');
                    this.log(`Loaded settings: ${JSON.stringify(loadedSettings)}`, 'info');
                    
                    // Compare settings using a more robust method that ignores property order
                    const compareObjects = (obj1, obj2) => {
                        const keys1 = Object.keys(obj1).sort();
                        const keys2 = Object.keys(obj2).sort();
                        
                        if (keys1.length !== keys2.length) return false;
                        
                        for (let key of keys1) {
                            if (obj1[key] !== obj2[key]) return false;
                        }
                        
                        return true;
                    };
                    
                    const settingsMatch = compareObjects(testSettings, loadedSettings);
                    
                    // Also check individual fields
                    const individualChecks = [
                        testSettings.focusTime === loadedSettings.focusTime,
                        testSettings.breakTime === loadedSettings.breakTime,
                        testSettings.longBreakTime === loadedSettings.longBreakTime,
                        testSettings.sessionsBeforeLongBreak === loadedSettings.sessionsBeforeLongBreak,
                        testSettings.soundEnabled === loadedSettings.soundEnabled
                    ];
                    
                    const allChecksPass = settingsMatch && individualChecks.every(check => check);
                    
                    this.addTestResult(
                        'Settings Storage',
                        'Test saving and loading settings',
                        allChecksPass,
                        allChecksPass ? 
                            'Settings saved and loaded successfully' : 
                            `Mismatch: Expected ${JSON.stringify(testSettings)}, Got ${JSON.stringify(loadedSettings)}`
                    );
                } catch (error) {
                    this.addTestResult(
                        'Settings Storage',
                        'Test saving and loading settings',
                        false,
                        `Error: ${error.message}`
                    );
                }

                // Test 5: Data Export
                try {
                    const exportedData = await this.testDatabase.exportData();
                    const hasRequiredFields = exportedData.sessions && exportedData.settings && exportedData.exportDate;
                    
                    this.addTestResult(
                        'Data Export',
                        'Test exporting database data',
                        hasRequiredFields,
                        `Exported ${exportedData.sessions.length} sessions and ${Object.keys(exportedData.settings).length} settings`
                    );
                } catch (error) {
                    this.addTestResult(
                        'Data Export',
                        'Test exporting database data',
                        false,
                        `Error: ${error.message}`
                    );
                }

                // Test 6: Database Size
                try {
                    const sizeInfo = await this.testDatabase.getDatabaseSize();
                    this.addTestResult(
                        'Database Size',
                        'Test getting database size information',
                        sizeInfo.sessionCount >= 0,
                        `Database contains ${sizeInfo.sessionCount} sessions, ${sizeInfo.totalSizeKB} KB`
                    );
                } catch (error) {
                    this.addTestResult(
                        'Database Size',
                        'Test getting database size information',
                        false,
                        `Error: ${error.message}`
                    );
                }
            }

            async runTimerTests() {
                this.log('Running timer tests...', 'info');
                
                // Test 1: Timer Initialization
                try {
                    // Create a test instance
                    const testTimer = {
                        timeLeft: 25 * 60,
                        totalTime: 25 * 60,
                        isRunning: false,
                        currentMode: 'focus'
                    };
                    
                    this.addTestResult(
                        'Timer Initialization',
                        'Test timer object creation',
                        testTimer.timeLeft === 1500 && testTimer.currentMode === 'focus',
                        `Timer initialized with ${testTimer.timeLeft} seconds`
                    );
                } catch (error) {
                    this.addTestResult(
                        'Timer Initialization',
                        'Test timer object creation',
                        false,
                        `Error: ${error.message}`
                    );
                }

                // Test 2: Time Formatting
                try {
                    const formatTime = (seconds) => {
                        const minutes = Math.floor(seconds / 60);
                        const remainingSeconds = seconds % 60;
                        return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
                    };

                    const testCases = [
                        { input: 1500, expected: '25:00' },
                        { input: 900, expected: '15:00' },
                        { input: 65, expected: '01:05' },
                        { input: 0, expected: '00:00' }
                    ];

                    let allPassed = true;
                    testCases.forEach(testCase => {
                        const result = formatTime(testCase.input);
                        if (result !== testCase.expected) {
                            allPassed = false;
                        }
                    });

                    this.addTestResult(
                        'Time Formatting',
                        'Test time display formatting',
                        allPassed,
                        `All ${testCases.length} test cases passed`
                    );
                } catch (error) {
                    this.addTestResult(
                        'Time Formatting',
                        'Test time display formatting',
                        false,
                        `Error: ${error.message}`
                    );
                }

                // Test 3: Mode Switching Logic
                try {
                    const testAutoSwitch = (currentMode, sessionCount, sessionsBeforeLongBreak) => {
                        if (currentMode === 'focus') {
                            return sessionCount % sessionsBeforeLongBreak === 0 ? 'long-break' : 'break';
                        } else {
                            return 'focus';
                        }
                    };

                    const testCases = [
                        { mode: 'focus', count: 4, before: 4, expected: 'long-break' },
                        { mode: 'focus', count: 3, before: 4, expected: 'break' },
                        { mode: 'break', count: 1, before: 4, expected: 'focus' },
                        { mode: 'long-break', count: 1, before: 4, expected: 'focus' }
                    ];

                    let allPassed = true;
                    testCases.forEach(testCase => {
                        const result = testAutoSwitch(testCase.mode, testCase.count, testCase.before);
                        if (result !== testCase.expected) {
                            allPassed = false;
                        }
                    });

                    this.addTestResult(
                        'Mode Switching',
                        'Test automatic mode switching logic',
                        allPassed,
                        `All ${testCases.length} test cases passed`
                    );
                } catch (error) {
                    this.addTestResult(
                        'Mode Switching',
                        'Test automatic mode switching logic',
                        false,
                        `Error: ${error.message}`
                    );
                }
            }

            async runUITests() {
                this.log('Running UI tests...', 'info');
                
                // Test 1: Test Environment DOM Elements
                try {
                    const testElements = [
                        'test-stats', 'test-results', 'console-output'
                    ];

                    let allElementsExist = true;
                    const missingElements = [];

                    testElements.forEach(elementId => {
                        const element = document.getElementById(elementId);
                        if (!element) {
                            allElementsExist = false;
                            missingElements.push(elementId);
                        }
                    });

                    // Also check for elements by class name
                    const testContainer = document.querySelector('.test-container');
                    const testHeader = document.querySelector('.test-header');
                    const testControls = document.querySelector('.test-controls');

                    const classElementsExist = testContainer && testHeader && testControls;

                    this.addTestResult(
                        'Test Environment DOM',
                        'Test test suite DOM elements exist',
                        allElementsExist && classElementsExist,
                        (allElementsExist && classElementsExist) ? 
                            'All test elements found' : 
                            `Missing IDs: ${missingElements.join(', ')}, Missing classes: ${!testContainer ? 'test-container ' : ''}${!testHeader ? 'test-header ' : ''}${!testControls ? 'test-controls' : ''}`
                    );
                } catch (error) {
                    this.addTestResult(
                        'Test Environment DOM',
                        'Test test suite DOM elements exist',
                        false,
                        `Error: ${error.message}`
                    );
                }

                // Test 2: DOM Manipulation
                try {
                    const testDiv = document.createElement('div');
                    testDiv.id = 'test-manipulation';
                    testDiv.className = 'test-element';
                    testDiv.textContent = 'Test Content';
                    
                    document.body.appendChild(testDiv);
                    
                    const foundElement = document.getElementById('test-manipulation');
                    const manipulationSuccess = foundElement && 
                        foundElement.className === 'test-element' && 
                        foundElement.textContent === 'Test Content';
                    
                    document.body.removeChild(testDiv);
                    
                    this.addTestResult(
                        'DOM Manipulation',
                        'Test creating, finding, and removing DOM elements',
                        manipulationSuccess,
                        'DOM manipulation operations work correctly'
                    );
                } catch (error) {
                    this.addTestResult(
                        'DOM Manipulation',
                        'Test creating, finding, and removing DOM elements',
                        false,
                        `Error: ${error.message}`
                    );
                }

                // Test 3: CSS Classes
                try {
                    const testElement = document.createElement('div');
                    testElement.className = 'btn btn-primary';
                    document.body.appendChild(testElement);
                    
                    const hasClasses = testElement.classList.contains('btn') && testElement.classList.contains('btn-primary');
                    document.body.removeChild(testElement);
                    
                    this.addTestResult(
                        'CSS Classes',
                        'Test CSS class application',
                        hasClasses,
                        'CSS classes applied correctly'
                    );
                } catch (error) {
                    this.addTestResult(
                        'CSS Classes',
                        'Test CSS class application',
                        false,
                        `Error: ${error.message}`
                    );
                }

                // Test 4: Event Handling
                try {
                    let eventHandled = false;
                    const testButton = document.createElement('button');
                    testButton.id = 'test-event-button';
                    testButton.textContent = 'Test Button';
                    
                    testButton.addEventListener('click', () => {
                        eventHandled = true;
                    });
                    
                    document.body.appendChild(testButton);
                    
                    // Simulate click
                    testButton.click();
                    
                    const eventSuccess = eventHandled;
                    document.body.removeChild(testButton);
                    
                    this.addTestResult(
                        'Event Handling',
                        'Test DOM event handling',
                        eventSuccess,
                        'Event handling works correctly'
                    );
                } catch (error) {
                    this.addTestResult(
                        'Event Handling',
                        'Test DOM event handling',
                        false,
                        `Error: ${error.message}`
                    );
                }

                // Test 5: Application Dependencies
                try {
                    // Add a small delay to ensure scripts are loaded
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Debug: Check what's actually in the window object
                    this.log(`Window object keys: ${Object.keys(window).filter(key => key.includes('Pomodoro')).join(', ')}`, 'info');
                    this.log(`unitTestsLoaded flag: ${window.unitTestsLoaded}`, 'info');
                    this.log(`PomodoroUnitTests type: ${typeof window.PomodoroUnitTests}`, 'info');
                    this.log(`PomodoroUnitTests value: ${window.PomodoroUnitTests}`, 'info');
                    
                    // Test if we can actually instantiate the class
                    try {
                        if (window.PomodoroUnitTests) {
                            const testInstance = new window.PomodoroUnitTests();
                            this.log(`Successfully created PomodoroUnitTests instance: ${typeof testInstance}`, 'success');
                        } else {
                            this.log('PomodoroUnitTests is not available', 'error');
                        }
                    } catch (error) {
                        this.log(`Error creating PomodoroUnitTests instance: ${error.message}`, 'error');
                    }
                    
                    const dependencies = [
                        { name: 'PomodoroDatabase', global: window.PomodoroDatabase },
                        { name: 'PomodoroTimer', global: window.PomodoroTimer },
                        { name: 'PomodoroUnitTests', global: window.PomodoroUnitTests }
                    ];

                    let allDependenciesLoaded = true;
                    const missingDependencies = [];

                    dependencies.forEach(dep => {
                        if (!dep.global) {
                            allDependenciesLoaded = false;
                            missingDependencies.push(dep.name);
                        }
                    });

                    // Debug logging
                    this.log(`Checking dependencies: ${dependencies.map(d => `${d.name}: ${d.global ? '‚úì' : '‚úó'}`).join(', ')}`, 'info');

                    this.addTestResult(
                        'Application Dependencies',
                        'Test required JavaScript classes are loaded',
                        allDependenciesLoaded,
                        missingDependencies.length === 0 ? 
                            'All dependencies loaded' : 
                            `Missing: ${missingDependencies.join(', ')}`
                    );
                } catch (error) {
                    this.addTestResult(
                        'Application Dependencies',
                        'Test required JavaScript classes are loaded',
                        false,
                        `Error: ${error.message}`
                    );
                }

                // Test 6: Browser Compatibility
                try {
                    const browserFeatures = [
                        { name: 'IndexedDB', test: () => 'indexedDB' in window },
                        { name: 'LocalStorage', test: () => 'localStorage' in window },
                        { name: 'Fetch API', test: () => 'fetch' in window },
                        { name: 'Promise', test: () => 'Promise' in window },
                        { name: 'Async/Await', test: () => {
                            try {
                                eval('async function test() {}');
                                return true;
                            } catch {
                                return false;
                            }
                        }}
                    ];

                    let allFeaturesSupported = true;
                    const unsupportedFeatures = [];

                    browserFeatures.forEach(feature => {
                        if (!feature.test()) {
                            allFeaturesSupported = false;
                            unsupportedFeatures.push(feature.name);
                        }
                    });

                    this.addTestResult(
                        'Browser Compatibility',
                        'Test required browser features are available',
                        allFeaturesSupported,
                        unsupportedFeatures.length === 0 ? 
                            'All features supported' : 
                            `Unsupported: ${unsupportedFeatures.join(', ')}`
                    );
                } catch (error) {
                    this.addTestResult(
                        'Browser Compatibility',
                        'Test required browser features are available',
                        false,
                        `Error: ${error.message}`
                    );
                }
            }

            async runIntegrationTests() {
                this.log('Running integration tests...', 'info');
                
                // Test 1: End-to-End Session Flow
                try {
                    // Simulate a complete Pomodoro session
                    const sessionData = {
                        task: 'Integration Test Task',
                        mode: 'focus',
                        duration: 1, // 1 minute for testing
                        completedAt: new Date().toISOString(),
                        sessionNumber: 999,
                        date: new Date().toISOString().split('T')[0],
                        hour: new Date().getHours(),
                        dayOfWeek: new Date().getDay(),
                        month: new Date().getMonth() + 1,
                        year: new Date().getFullYear()
                    };

                    // Add to database
                    const sessionId = await this.testDatabase.addSession(sessionData);
                    
                    // Retrieve and verify
                    const sessions = await this.testDatabase.getAllSessions();
                    const foundSession = sessions.find(s => s.id === sessionId);
                    
                    const integrationPassed = foundSession && 
                        foundSession.task === sessionData.task &&
                        foundSession.mode === sessionData.mode;
                    
                    this.addTestResult(
                        'End-to-End Session',
                        'Test complete session flow (create, store, retrieve)',
                        integrationPassed,
                        `Session ${integrationPassed ? 'completed successfully' : 'failed'}`
                    );
                } catch (error) {
                    this.addTestResult(
                        'End-to-End Session',
                        'Test complete session flow (create, store, retrieve)',
                        false,
                        `Error: ${error.message}`
                    );
                }

                // Test 2: Settings Persistence
                try {
                    const testSettings = {
                        focusTime: 45,
                        breakTime: 10,
                        longBreakTime: 20,
                        sessionsBeforeLongBreak: 6,
                        soundEnabled: false
                    };

                    // Clear existing settings first
                    await this.testDatabase.clearSettings();
                    
                    // Save test settings
                    await this.testDatabase.saveSettings(testSettings);
                    
                    // Load settings from the same database instance
                    const loadedSettings = await this.testDatabase.loadSettings();
                    
                    // Use robust comparison that ignores property order
                    const compareObjects = (obj1, obj2) => {
                        const keys1 = Object.keys(obj1).sort();
                        const keys2 = Object.keys(obj2).sort();
                        
                        if (keys1.length !== keys2.length) return false;
                        
                        for (let key of keys1) {
                            if (obj1[key] !== obj2[key]) return false;
                        }
                        
                        return true;
                    };
                    
                    const settingsPersisted = compareObjects(testSettings, loadedSettings);
                    
                    // Debug logging
                    this.log(`Original settings: ${JSON.stringify(testSettings)}`, 'info');
                    this.log(`Loaded settings: ${JSON.stringify(loadedSettings)}`, 'info');
                    
                    this.addTestResult(
                        'Settings Persistence',
                        'Test settings persistence within database instance',
                        settingsPersisted,
                        settingsPersisted ? 
                            'Settings persisted correctly' : 
                            `Mismatch: Expected ${JSON.stringify(testSettings)}, Got ${JSON.stringify(loadedSettings)}`
                    );
                } catch (error) {
                    this.addTestResult(
                        'Settings Persistence',
                        'Test settings persistence within database instance',
                        false,
                        `Error: ${error.message}`
                    );
                }

                // Test 2b: Settings Fallback to localStorage
                try {
                    const testSettings = {
                        focusTime: 30,
                        breakTime: 5,
                        longBreakTime: 15,
                        sessionsBeforeLongBreak: 4,
                        soundEnabled: true
                    };

                    // Save to localStorage (simulating fallback)
                    localStorage.setItem('pomodoroSettings', JSON.stringify(testSettings));
                    
                    // Load from localStorage
                    const loadedFromStorage = JSON.parse(localStorage.getItem('pomodoroSettings') || '{}');
                    
                    const compareObjects = (obj1, obj2) => {
                        const keys1 = Object.keys(obj1).sort();
                        const keys2 = Object.keys(obj2).sort();
                        
                        if (keys1.length !== keys2.length) return false;
                        
                        for (let key of keys1) {
                            if (obj1[key] !== obj2[key]) return false;
                        }
                        
                        return true;
                    };
                    
                    const localStoragePersisted = compareObjects(testSettings, loadedFromStorage);
                    
                    this.addTestResult(
                        'Settings localStorage Fallback',
                        'Test settings persistence using localStorage fallback',
                        localStoragePersisted,
                        localStoragePersisted ? 
                            'localStorage fallback works correctly' : 
                            `localStorage mismatch: Expected ${JSON.stringify(testSettings)}, Got ${JSON.stringify(loadedFromStorage)}`
                    );
                } catch (error) {
                    this.addTestResult(
                        'Settings localStorage Fallback',
                        'Test settings persistence using localStorage fallback',
                        false,
                        `Error: ${error.message}`
                    );
                }

                // Test 3: Data Export/Import
                try {
                    // Export data
                    const exportedData = await this.testDatabase.exportData();
                    
                    // Create new database and import
                    const importDatabase = new PomodoroDatabase();
                    await importDatabase.init();
                    await importDatabase.importData(exportedData);
                    
                    // Verify import
                    const importedSessions = await importDatabase.getAllSessions();
                    const importedSettings = await importDatabase.loadSettings();
                    
                    const importSuccess = importedSessions.length === exportedData.sessions.length &&
                        JSON.stringify(importedSettings) === JSON.stringify(exportedData.settings);
                    
                    this.addTestResult(
                        'Data Export/Import',
                        'Test complete data export and import cycle',
                        importSuccess,
                        `Exported ${exportedData.sessions.length} sessions, imported ${importedSessions.length} sessions`
                    );
                } catch (error) {
                    this.addTestResult(
                        'Data Export/Import',
                        'Test complete data export and import cycle',
                        false,
                        `Error: ${error.message}`
                    );
                }
            }

            clearResults() {
                this.testResults = [];
                this.totalTests = 0;
                this.passedTests = 0;
                this.failedTests = 0;
                
                document.getElementById('test-results').innerHTML = '';
                document.getElementById('console-output').innerHTML = 
                    '<div class="console-line info">Test console cleared. Ready for new tests.</div>';
                
                this.updateStats();
            }
        }

        // Global test suite instance
        let testSuite = new PomodoroTestSuite();

        // Global functions for button clicks
        function runAllTests() {
            testSuite.runAllTests();
        }

        function runDatabaseTests() {
            testSuite.clearResults();
            testSuite.runDatabaseTests();
        }

        function runTimerTests() {
            testSuite.clearResults();
            testSuite.runTimerTests();
        }

        function runUITests() {
            testSuite.clearResults();
            testSuite.runUITests();
        }

        function clearTestResults() {
            testSuite.clearResults();
        }

        function runUnitTests() {
            testSuite.clearResults();
            testSuite.log('Running unit tests...', 'info');
            
            // Debug: Check if the class is available
            testSuite.log(`unitTestsScriptLoaded flag: ${window.unitTestsScriptLoaded}`, 'info');
            testSuite.log(`PomodoroUnitTests available: ${typeof window.PomodoroUnitTests}`, 'info');
            testSuite.log(`unitTestsLoaded flag: ${window.unitTestsLoaded}`, 'info');
            testSuite.log(`Window Pomodoro keys: ${Object.keys(window).filter(key => key.includes('Pomodoro')).join(', ')}`, 'info');
            
            // Run unit tests and capture console output
            const originalLog = console.log;
            const logs = [];
            console.log = (...args) => {
                logs.push(args.join(' '));
                originalLog.apply(console, args);
            };
            
            try {
                // Check if class exists before trying to use it
                if (typeof window.PomodoroUnitTests === 'undefined') {
                    throw new Error('PomodoroUnitTests class is not loaded. Check if unit-tests.js has syntax errors.');
                }
                
                // Create a new instance of PomodoroUnitTests and run the tests
                const unitTests = new PomodoroUnitTests();
                const results = unitTests.runAllUnitTests();
                
                // Add unit test results to the test suite
                results.results.forEach(test => {
                    testSuite.addTestResult(
                        test.name,
                        test.description,
                        test.passed,
                        test.passed ? 'Unit test passed' : 'Unit test failed'
                    );
                });
                
                testSuite.log(`Unit tests completed: ${results.passed}/${results.total} passed`, 
                    results.failed === 0 ? 'success' : 'warning');
                    
            } catch (error) {
                testSuite.log(`Unit tests failed: ${error.message}`, 'error');
                testSuite.log(`Error stack: ${error.stack}`, 'error');
            } finally {
                console.log = originalLog;
            }
        }

        // Initialize test suite when page loads
        document.addEventListener('DOMContentLoaded', () => {
            testSuite.log('Test suite initialized and ready.', 'success');
        });
    </script>
</body>
</html> 